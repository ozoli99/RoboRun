# RoboRun
### Windows Forms grafikus fel√ºlet≈± alkalmaz√°s - egyetemi beadand√≥ feladat

## Feladat
K√©sz√≠ts√ºnk programot, amellyel a k√∂vetkez≈ë j√°t√©kot j√°tszhatjuk.

Adott egy ùëõ √ó ùëõ mez≈ëb≈ël √°ll√≥ j√°t√©kp√°lya, amelyben egy elszabadult robot bolyong,
√©s a feladatunk az, hogy beterelj√ºk a p√°lya k√∂zep√©n tal√°lhat√≥ m√°gnes al√°, √©s √≠gy
elkapjuk.

A robot v√©letlenszer≈± poz√≠ci√≥ban kezd, √©s adott id≈ëk√∂z√∂nk√©nt l√©p egy mez≈ët
(v√≠zszintesen, vagy f√ºgg≈ëlegesen) √∫gy, hogy √°ltal√°ban folyamatosan el≈ëre halad
eg√©szen addig, am√≠g falba nem √ºtk√∂zik. Ekkor v√©letlenszer≈±en v√°laszt egy √∫j
ir√°nyt, √©s arra halad tov√°bb. Id≈ënk√©nt m√©g jobban megkerg√ºl, √©s akkor is ir√°nyt
v√°lt, amikor nem √ºtk√∂zik falba.

A j√°t√©kos a robot terel√©s√©t √∫gy hajthatja v√©gre, hogy egy mez≈ët kiv√°lasztva falat
emelhet r√°. A felh√∫zott falak azonban nem t√∫l strapab√≠r√≥ak. Ha a robot √ºtk√∂zik a
fallal, akkor az ut√°na eld≈ël. A led≈ëlt falakat m√°r nem lehet √∫jra felh√∫zni, ott a
robot k√©s≈ëbb akad√°ly n√©lk√ºl √°thaladhat.

A program biztos√≠tson lehet≈ës√©get √∫j j√°t√©k kezd√©s√©re a p√°lyam√©ret megad√°s√°val
(7 √ó 7, 11 √ó 11, 15 √ó 15), valamint j√°t√©k sz√ºneteltet√©s√©re (ekkor nem telik az id≈ë,
nem l√©p a robot, √©s nem lehet mez≈ët se kiv√°lasztani). Ismerje fel, ha v√©ge a
j√°t√©knak, √©s jelen√≠tse meg, hogy milyen id≈ëvel gy≈ëz√∂tt a j√°t√©kos. A program j√°t√©k
k√∂zben folyamatosan jelezze ki a j√°t√©kid≈ët. Ezen fel√ºl sz√ºneteltet√©s alatt legyen
lehet≈ës√©g a j√°t√©k elment√©s√©re, valamint bet√∂lt√©s√©re

## K√∂z√∂s k√∂vetelm√©nyek:
- A beadand√≥k dokument√°ci√≥b√≥l, valamint programb√≥l √°llnak, ut√≥bbi csak a
megfelel≈ë dokument√°ci√≥ bemutat√°s√°val √©rt√©kelhet≈ë. Csak funkcion√°lisan teljes, a
feladatnak megfelel≈ë, √∂n√°ll√≥an megval√≥s√≠tott, szem√©lyesen bemutatott program
fogadhat√≥ el.
- A megval√≥s√≠t√°snak felhaszn√°l√≥bar√°tnak, √©s k√∂nnyen kezelhet≈ënek kell lennie. A
szerkezet√©ben t√∂rekednie kell az objektumorient√°lt szeml√©let megtart√°s√°ra.
- A programot h√°romr√©teg≈± (modell/n√©zet/perzisztencia) architekt√∫r√°ban kell
fel√©p√≠teni, amelyben elk√ºl√∂n√ºl a megjelen√≠t√©s, az √ºzleti logika, valamint az
adatel√©r√©s (amennyiben r√©sze a feladatnak). Az egyes r√©tegeknek megfelel≈ë
funkcionalit√°st kell biztos√≠tania, √©s megfelel≈ë hierarchi√°ban kell kommunik√°lnia
(pl. a modell csak esem√©nyekkel kommunik√°lhat a n√©zettel, a n√©zet nem
v√©gezheti az adatkezel√©st).
- A modell m≈±k√∂d√©s√©t egys√©gtesztek seg√≠ts√©g√©vel kell ellen≈ërizni. Nem kell teljes
k√∂r≈± tesztet v√©gezni, azonban a l√©nyeges funkci√≥kat, √©s azok hat√°sait ellen≈ërizni
kell. Az adatbet√∂lt√©s/ment√©s tesztel√©s√©hez a perzisztencia m≈±k√∂d√©s√©t szimul√°lni
kell.
- A program j√°t√©kfel√ºlet√©t dinamikusan kell l√©trehozni fut√°si id≈ëben. A
megjelen√≠t√©shez lehet vez√©rl≈ëket haszn√°lni, vagy elemi grafik√°t. Egyes
feladatokn√°l k√ºl√∂nb√∂z≈ë m√©ret≈± j√°t√©kt√°bla l√©trehoz√°s√°t kell megval√≥s√≠tani, ekkor
√ºgyelni kell arra, hogy az ablakm√©ret mindig alkalmazkodjon a j√°t√©kt√°bla
m√©ret√©hez.
- A dokument√°ci√≥nak j√≥l √°ttekinthet≈ënek, megfelel≈ëen form√°zottnak kell lennie,
tartalmaznia kell a fejleszt≈ë adatait, a feladatle√≠r√°st, a feladat elemz√©s√©t,
felhaszn√°l√≥i eseteit (UML felhaszn√°l√≥i esetek diagrammal), a program
szerkezet√©nek le√≠r√°s√°t (UML oszt√°lydiagrammal), valamint a tesztesetek le√≠r√°s√°t.
A dokument√°ci√≥ ne tartalmazzon k√≥dr√©szleteket, illetve k√©perny≈ëk√©peket. A
megjelen≈ë diagramokat megfelel≈ë szerkeszt≈ëeszk√∂z seg√≠ts√©g√©vel kell el≈ë√°ll√≠tani.
A dokument√°ci√≥t elektronikusan, PDF form√°tumban kell leadni.

## Elemz√©s
- A j√°t√©kot h√°rom p√°lyam√©rettel j√°tszhatjuk: (7 √ó 7), (11 √ó 11), (15 √ó 15). 
A program ind√≠t√°skor (11 x 11)-es m√©retet √°ll√≠t be, √©s automatikusan √∫j j√°t√©kot ind√≠t.
- A feladatot egyablakos asztali alkalmaz√°sk√©nt Windows Forms grafikus fel√ºlettel val√≥s√≠tjuk meg.
- Az ablakban elhelyez√ºnk egy men√ºt a k√∂vetkez≈ë men√ºpontokkal: 
File (√öj j√°t√©k, J√°t√©k bet√∂lt√©se, J√°t√©k ment√©se, Kil√©p√©s), Be√°ll√≠t√°sok ((7 √ó 7), (11 √ó 11), (15 √ó 15)).
Az ablak alj√°n megjelen√≠t√ºnk egy st√°tuszsort, amely a h√°tral√©v≈ë id≈ët jelzi.
- A j√°t√©kt√°bl√°t a be√°ll√≠t√°soknak megfelel≈ë m√©ret≈± nyom√≥gombokb√≥l √°ll√≥ r√°cs reprezent√°lja.
A nyom√≥gomb eg√©rkattint√°s hat√°s√°ra lerak egy falat az adott ter√ºletre. Falat a robot vagy egy m√°r lent l√©v≈ë fal
poz√≠ci√≥j√°ra nem lehet lerakni. Lent l√©v≈ë fal poz√≠ci√≥j√°ra k√©s≈ëbb, esetleges led≈ël√©s eset√©n sem lehet m√°r √∫j falat lerakni.
- A j√°t√©k automatikusan feldob egy dial√≥gusablakot, amikor v√©ge a j√°t√©knak (siker√ºlt beterelni a robotot a p√°lya k√∂zep√©n
tal√°lhat√≥ m√°gnes al√°). Szint√©n dial√≥gusablakkal v√©gezz√ºk el a ment√©st, illetve bet√∂lt√©st is, a f√°jlneveket a felhaszn√°l√≥ adja meg.

![Use case diagram](https://github.com/ozoli99/RoboRun/blob/main/Media/UseCaseDiagram.jpg)

## Tervez√©s
### Programszerkezet
- A programot h√°romr√©teg≈± architekt√∫r√°ban val√≥s√≠tjuk meg. A megjelen√≠t√©s a **RoboRun.View**, a modell a **RoboRun.Model**, 
m√≠g a perzisztencia a **RoboRun.Persistence** n√©vt√©rben helyezkedik el.
Tov√°bb√° a r√©tegeket k√ºl√∂n projektk√©nt adjuk hozz√° az √∫jrafelhaszn√°lhat√≥s√°g √©rdek√©ben.

![Application package diagram](https://github.com/ozoli99/RoboRun/blob/main/Media/ApplicationPackageDiagram.jpg)

### Perzisztencia
- Az adatkezel√©s feladata a RoboRun t√°bl√°val kapcsolatos inform√°ci√≥k t√°rol√°sa, valamint a bet√∂lt√©s/ment√©s biztos√≠t√°sa.
- A **RoboRunTable** oszt√°ly egy √©rv√©nyes RoboRun t√°bl√°t biztos√≠t (azaz mindig ellen≈ërzi a be√°ll√≠tott √©rt√©keket), 
ahol minden mez≈ër≈ël ismert a z√°rolts√°ga (**_fieldLocks**).
Ezt akkor alkalmazzuk, ha a mez≈ë a Home mez≈ë, esetleg robot tart√≥zkodik rajta, vagy m√°r √©p√ºlt r√° fal. 
A t√°bla alap√©rtelmez√©s szerint (11 x 11)-es, de ez a konstruktorban param√©terezhet≈ë, le√≠r√°s szerint (7 x 7) vagy (15 x 15) 
m√©ret≈±re v√°ltoztathat√≥. A t√°bla lehet≈ës√©get ad √°llapotok lek√©rdez√©s√©re (**HasWall**, **IsRobot**, **IsHome**, **GetWall**, **IsLocked**), 
illetve be√°ll√≠t√°s√°ra (**BuildWall**, **SetLock**).
- A hossz√∫ t√°v√∫ adatt√°rol√°s lehet≈ës√©geit az **IRoboRunDataAccess** interf√©sz adja meg, amely lehet≈ës√©get ad a t√°bla bet√∂lt√©s√©re (**LoadAsync**), 
valamint ment√©s√©re (**SaveAsync**). A m≈±veleteket hat√©konys√°gi okokb√≥l aszinkron m√≥don val√≥s√≠tjuk meg.
- Az interf√©szt sz√∂veges f√°jl alap√∫ adatkezel√©sre a RoboRunFileDataAccess oszt√°ly val√≥s√≠tja meg. A f√°jlkezel√©s sor√°n fell√©p≈ë hib√°kat a 
**RoboRunDataException** kiv√©tel jelzi.
- A program az adatokat sz√∂veges f√°jlk√©nt tudja elt√°rolni, melyek az **rrt** kiterjeszt√©st kapj√°k. 
Ezeket az adatokat a programban b√°rmikor be lehet t√∂lteni, illetve ki lehet menteni az aktu√°lis √°ll√°st.
- A f√°jl els≈ë sora megadja az eltelt j√°t√©kid≈ët, valamint a t√°bla m√©ret√©t. A f√°jl t√∂bbi r√©sze izomorf lek√©pez√©se a j√°t√©kt√°bl√°nak, 
azaz a t√°bla m√©ret√©nek megfelel≈ë sz√°m√∫ sor k√∂vetkezik ugyanennyi sz√°mmal soronk√©nt. Ezek a sz√°mok a 0 √©s 1 √©rt√©ket vehetik fel,
a mez≈ë z√°rolts√°g√°nak megfelel≈ëen. Ezut√°n a robot adatai k√∂vetkeznek egy sorban, majd m√©g egy sorban a falak sz√°ma. 
Az ut√≥bbi sz√°mnak megfelel≈ë mennyis√©g≈± sorban pedig a falak adatai k√∂vetkeznek.

### Modell
- A modell l√©nyegi r√©sz√©t a **RoboRunModel** oszt√°ly val√≥s√≠tja meg, amely szab√°lyozza a t√°bla tev√©kenys√©geit, 
valamint a j√°t√©k egy√©b param√©tereit, √∫gymint az id≈ë (**_gameTime**). A t√≠pus lehet≈ës√©get ad √∫j j√°t√©k kezd√©s√©re (**NewGame**),
valamint l√©p√©sre (**Step**). √öj j√°t√©kn√°l megadhat√≥ a j√°t√©kt√°bla m√©rete is, k√ºl√∂nben alap√©rtelmezetten (11 x 11)-es m√©ret≈± lesz.
Az id≈ë el≈ërel√©ptet√©s√©t id≈ëbeli l√©p√©sek v√©gz√©s√©vel (**AdvanceTime**) tehetj√ºk meg.
- Az id≈ë m√∫l√°s√°r√≥l a **GameTimeAdvanced**, az id≈ë meg√°ll√≠t√°s√°r√≥l a **GameTimePaused**, a robot mozg√°s√°r√≥l a **RobotMoved**,
a j√°t√©k v√©g√©r≈ël pedig a **GameWin** esem√©nyek t√°j√©koztatnak. Az esem√©nyek argumentuma (a **RobotMoved** esem√©nyen k√≠v√ºl) (**RoboRunEventArgs**)
t√°rolja az eltelt j√°t√©k id≈ët.
- A modell p√©ld√°nyos√≠t√°skor megkapja az adatkezel√©s fel√ºlet√©t, amelynek seg√≠ts√©g√©vel lehet≈ës√©get ad 
bet√∂lt√©sre (**LoadAsync**) √©s ment√©sre (**SaveAsync**).
- A j√°t√©kt√°bla m√©ret√©t a **GameTableSize** felsorol√°si t√≠puson √°t kezelj√ºk, √©s a **RoboRunModel** oszt√°lyban konstansok 
seg√≠ts√©g√©vel t√°roljuk az egyes m√©retek param√©tereit.

### N√©zet
- A n√©zetet a **GameForm** oszt√°ly biztos√≠tja, amely t√°rolja a modell egy p√©ld√°ny√°t (**_model**),
valamint az adatel√©r√©s konkr√©t p√©ld√°ny√°t (**_dataAccess**).
- A j√°t√©kt√°bl√°t egy dinamikusan l√©trehozott gombmez≈ë (**_buttonGrid**) reprezent√°lja. 
A fel√ºleten l√©trehozzuk a megfelel≈ë men√ºpontokat, illetve st√°tuszsort, valamint dial√≥gusablakokat, 
√©s a hozz√°juk tartoz√≥ esem√©nykezel≈ëket. A j√°t√©kt√°bla gener√°l√°s√°t (**GenerateGameTable**), 
illetve az √©rt√©kek be√°ll√≠t√°s√°t (**SetupGameTable**) k√ºl√∂n met√≥dusok v√©gzik.
- A j√°t√©k id≈ëbeli kezel√©s√©t egy id≈ëz√≠t≈ë v√©gzi (**_timer**), ahogy robot mozg√°s√°t is ez vez√©rli (**_robotTimer**).
Ezeket mindig aktiv√°ljuk a j√°t√©k sor√°n, illetve inaktiv√°ljuk, amennyiben bizonyos men√ºfunkci√≥k futnak.

![Class diagram](https://github.com/ozoli99/RoboRun/blob/main/Media/ClassDiagram.jpg)

## Tesztel√©s
- A modell funkcionalit√°sa egys√©gtesztek seg√≠ts√©g√©vel lett ellen≈ërizve a **TestModel** oszt√°lyban.
- Az al√°bbi tesztesetek ker√ºltek megval√≥s√≠t√°sra:
  - **RoboRunModelNewGameSmallTest**, **RoboRunModelNewGameMediumTest**, **RoboRunModelNewGameBigTest**:
  √öj j√°t√©k ind√≠t√°sa, a mez≈ëk kit√∂lt√©se, valamint a t√°bla m√©ret√©nek ellen≈ërz√©se a be√°ll√≠tott m√©ret alapj√°n
  - **RoboRunModelStepTest**: J√°t√©kbeli l√©p√©s hat√°sainak ellen≈ërz√©se, j√°t√©k megkezd√©se el≈ëtt, valamint ut√°n.
  - **RoboRunModelAdvanceTimeTest**: A j√°t√©kbeli id≈ë kezel√©s√©nek ellen≈ërz√©se.
  - **RoboRunModelLoadTest**: A j√°t√©k modell bet√∂lt√©s√©nek tesztel√©se mockolt perzisztencia r√©teggel.
